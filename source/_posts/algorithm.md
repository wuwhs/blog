---
title: algorithm
date: 2020-08-20 19:43:27
tags: [javascript, algorithm]
---

## 冒泡排序（Bubble Sort）

### 基本思想

给定一个数组，我们把数组里的元素通通倒入到水池中，这些元素将通过相互之间的比较，按照大小顺序一个一个地像气泡一样浮出水面。

### 实现

每一轮，从杂乱无章的数组头部开始，每两个元素比较大小并进行交换，直到这一轮当中最大或最小的元素被放置在数组的尾部，然后不断地重复这个过程，直到所有元素都排好位置。其中，核心操作就是元素相互比较。

### 例题分析

给定数组 [2, 1, 7, 9, 5, 8]，要求按照从左到右、从小到大的顺序进行排序。

### 解题思路

从左到右依次冒泡，把较大的数往右边挪动即可。

![bubble-sort](/gb/algorithm/bubble-sort.gif )

- 首先指针指向第一个数，比较第一个数和第二个数的大小，由于 2 比 1 大，所以两两交换，[1, 2, 7, 9, 5, 8]。
- 接下来指针往前移动一步，比较 2 和 7，由于 2 比 7 小，两者保持不动，[1, 2, 7, 9, 5, 8]。到目前为止，7 是最大的那个数。
- 指针继续往前移动，比较 7 和 9，由于 7 比 9 小，两者保持不动，[1, 2, 7, 9, 5, 8]。现在，9 变成了最大的那个数。
- 再往后，比较 9 和 5，很明显，9 比 5 大，交换它们的位置，[1, 2, 7, 5, 9, 8]。
- 最后，比较 9 和 8，9 比 8 大，交换它们的位置，[1, 2, 7, 5, 8, 9]。经过第一轮的两两比较，9 这个最大的数就像冒泡一样冒到了数组的最后面。
- 接下来进行第二轮的比较，把指针重新指向第一个元素，重复上面的操作，最后，数组变成了：[1, 2, 5, 7, 8, 9]。
- 在进行新一轮的比较中，判断一下在上一轮比较的过程中有没有发生两两交换，如果一次交换都没有发生，就证明其实数组已经排好序了。

### 代码示例

```js
// 冒泡排序算法
const bubbleSort = function (arr) {
  const len = arr.length
  // 标记每一轮是否发生来交换
  let hasChange = true

  // 如果没有发生交换则已经是排好序的，直接跳出外层遍历
  for (let i = 0; i < len && hasChange; i++) {
    hasChange = false
    for (let j = 0; j < len - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        let temp = arr[j]
        arr[j] = arr[j + 1]
        arr[j + 1] = temp
        hasChange = true
      }
    }
  }
}

const arr = [2, 1, 7, 9, 5, 8]
bubbleSort(arr)
console.log('arr: ', arr)
```

### 算法分析

#### 空间复杂度

假设数组的元素个数是 `n`，由于在整个排序的过程中，我们是直接在给定的数组里面进行元素的两两交换，所以空间复杂度是 `O(1)`。

#### 时间复杂度

给定的数组按照顺序已经排好

- 在这种情况下，我们只需要进行 `n−1` 次的比较，两两交换次数为 `0`，时间复杂度是 `O(n)`。这是最好的情况。

- 给定的数组按照逆序排列。在这种情况下，我们需要进行 `n(n-1)/2` 次比较，时间复杂度是 `O(n2)`。这是最坏的情况。

- 给定的数组杂乱无章。在这种情况下，平均时间复杂度是 `O(n2)`。

由此可见，冒泡排序的时间复杂度是 `O(n2)`。它是一种稳定的排序算法。（稳定是指如果数组里两个相等的数，那么排序前后这两个相等的数的相对位置保持不变。）

## 插入排序（Insertion Sort）

### 基本思想

不断地将尚未排好序的数插入到已经排好序的部分。

### 特点

在冒泡排序中，经过每一轮的排序处理后，数组后端的数是排好序的；而对于插入排序来说，经过每一轮的排序处理后，数组前端的数都是排好序的。

### 例题分析

对数组 [2, 1, 7, 9, 5, 8] 进行插入排序。

### 解题思路

- 首先将数组分成左右两个部分，左边是已经排好序的部分，右边是还没有排好序的部分，刚开始，左边已排好序的部分只有第一个元素 2。接下来，我们对右边的元素一个一个进行处理，将它们放到左边。

![insertion-sort](/gb/algorithm/insertion-sort.gif)

- 先来看 1，由于 1 比 2 小，需要将 1 插入到 2 的前面，做法很简单，两两交换位置即可，[1, 2, 7, 9, 5, 8]。
- 然后，我们要把 7 插入到左边的部分，由于 7 已经比 2 大了，表明它是目前最大的元素，保持位置不变，[1, 2, 7, 9, 5, 8]。
- 同理，9 也不需要做位置变动，[1, 2, 7, 9, 5, 8]。
- 接下来，如何把 5 插入到合适的位置。首先比较 5 和 9，由于 5 比 9 小，两两交换，[1, 2, 7, 5, 9, 8]，继续，由于 5 比 7 小，两两交换，[1, 2, 5, 7, 9, 8]，最后，由于 5 比 2 大，此轮结束。
- 最后一个数是 8，由于 8 比 9 小，两两交换，[1, 2, 5, 7, 8, 9]，再比较 7 和 8，发现 8 比 7 大，此轮结束。到此，插入排序完毕。

### 代码示例

```js
// 插入排序
const insertionSort = function (arr) {
  const len = arr.length
  for (let i = 1; i < len; i++) {
    let current = arr[i]
    for (let j = i - 1; j >= 0; j--) {
      // current 小于 j 指向的左侧值，将 j 指向左侧值右移一位
      if (current < arr[j]) {
        arr[j + 1] = arr[j]
      } else {
        // 否则将 current 插入到 j 位置，跳出内循环
        arr[j] = current
        break
      }
    }
  }
}

const arr = [2, 1, 7, 9, 5, 8]
insertionSort(arr)
console.log('arr: ', arr)
```

### 算法分析

#### 空间复杂度

假设数组的元素个数是 n，由于在整个排序的过程中，是直接在给定的数组里面进行元素的两两交换，空间复杂度是 O(1)。

#### 时间复杂度

- 给定的数组按照顺序已经排好。只需要进行 n-1 次的比较，两两交换次数为 0，时间复杂度是 O(n)。这是最好的情况。
- 给定的数组按照逆序排列。在这种情况下，我们需要进行 n(n-1)/2 次比较，时间复杂度是 O(n2)。这是最坏的情况。
- 给定的数组杂乱无章。在这种情况下，平均时间复杂度是 O(n2)。 

由此可见，和冒泡排序一样，插入排序的时间复杂度是 O(n2)，并且它也是一种稳定的排序算法。

## 归并排序（Merge Sort）

### 基本思想

核心是分治，就是把一个复杂的问题分成两个或多个相同或相似的子问题，然后把子问题分成更小的子问题，直到子问题可以简单的直接求解，最原问题的解就是子问题解的合并。归并排序将分治的思想体现得淋漓尽致。

### 实现

一开始先把数组从中间划分成两个子数组，一直递归地把子数组划分成更小的子数组，直到子数组里面只有一个元素，才开始排序。 

排序的方法就是按照大小顺序合并两个元素，接着依次按照递归的返回顺序，不断地合并排好序的子数组，直到最后把整个数组的顺序排好。

### 代码示例

```js
// 归并排序
const mergeSort = function (arr, lo = 0, hi = arr.length - 1) {
  // 判断是否剩下最后一个元素
  if (lo >= hi) return

  // 从中间将数组分成两部分
  let mid = lo + Math.floor((hi - lo) / 2)

  // 分别递归将左右两边排好序
  mergeSort(arr, lo, mid)
  mergeSort(arr, mid + 1, hi)

  // 将排好序的左右两半合并
  merge(arr, lo, mid, hi)
}

const merge = function (arr, lo, mid, hi) {
  // 复制一份原来的数组
  const copy = [...arr]

  // 定义一个 k 指针表示从什么位置开始修改原来的数组，
  // i 指针表示左边半的起始位置
  // j 指针便是右半边的其实位置
  let k = lo
  let i = lo
  let j = mid + 1

  while (k <= hi) {
    if (i > mid) {
      arr[k++] = copy[j++]
    } else if (j > hi) {
      arr[k++] = copy[i++]
    } else if (copy[j] < copy[i]) {
      arr[k++] = copy[j++]
    } else {
      arr[k++] = copy[i++]
    }
  }
}
const arr = [2, 1, 7, 9, 5, 8]
mergeSort(arr)
console.log('arr: ', arr)
```

其中，`While` 语句比较，一共可能会出现四种情况。

- 左半边的数都处理完毕，只剩下右半边的数，只需要将右半边的数逐个拷贝过去。
- 右半边的数都处理完毕，只剩下左半边的数，只需要将左半边的数逐个拷贝过去就好。
- 右边的数小于左边的数，将右边的数拷贝到合适的位置，j 指针往前移动一位。
- 左边的数小于右边的数，将左边的数拷贝到合适的位置，i 指针往前移动一位。

### 例题分析

利用归并排序算法对数组 [2, 1, 7, 9, 5, 8] 进行排序。

### 解题思路

![merge-sort](/gb/algorithm/merge-sort.gif)

首先不断地对数组进行切分，直到各个子数组里只包含一个元素。
接下来递归地按照大小顺序合并切分开的子数组，递归的顺序和二叉树里的前向遍历类似。

- 合并 [2] 和 [1] 为 [1, 2]。
- 子数组 [1, 2] 和 [7] 合并。
- 右边，合并 [9] 和 [5]。
- 然后合并 [5, 9] 和 [8]。
- 最后合并 [1, 2, 7] 和 [5, 8, 9] 成 [1, 2, 5, 8, 9]，就可以把整个数组排好序了。 

合并数组 [1, 2, 7] 和 [5, 8, 9] 的操作步骤如下。

![merge-array](/gb/algorithm/merge-array.gif)

- 把数组 [1, 2, 7] 用 L 表示，[5, 8, 9] 用 R 表示。
- 合并的时候，开辟分配一个新数组 T 保存结果，数组大小应该是两个子数组长度的总和
- 然后下标 i、j、k 分别指向每个数组的起始点。
- 接下来，比较下标i和j所指向的元素 L[i] 和 R[j]，按照大小顺序放入到下标 k 指向的地方，1 小于 5。
- 移动 i 和 k，继续比较 L[i] 和 R[j]，2 比 5 小。
- i 和 k 继续往前移动，5 比 7 小。
- 移动 j 和 k，继续比较 L[i] 和 R[j]，7 比 8 小。
- 这时候，左边的数组已经处理完毕，直接将右边数组剩余的元素放到结果数组里就好。

合并之所以能成功，先决条件必须是两个子数组都已经分别排好序了。

### 算法分析

#### 空间复杂度
由于合并 n 个元素需要分配一个大小为 `n` 的额外数组，合并完成之后，这个数组的空间就会被释放，所以算法的空间复杂度就是 `O(n)`。归并排序也是稳定的排序算法。

#### 时间复杂度

归并算法是一个不断递归的过程。

举例：数组的元素个数是 `n`，时间复杂度是 `T(n)` 的函数。

解法：把这个规模为 `n` 的问题分成两个规模分别为 `n/2` 的子问题，每个子问题的时间复杂度就是 `T(n/2)`，那么两个子问题的复杂度就是 `2×T(n/2)`。当两个子问题都得到了解决，即两个子数组都排好了序，需要将它们合并，一共有 n 个元素，每次都要进行最多 `n-1` 次的比较，所以合并的复杂度是 `O(n)`。由此我们得到了递归复杂度公式：`T(n) = 2×T(n/2) + O(n)`。

对于公式求解，不断地把一个规模为 `n` 的问题分解成规模为 `n/2` 的问题，一直分解到规模大小为 `1`。如果 `n` 等于 `2`，只需要分一次；如果 `n` 等于 `4`，需要分 `2` 次。这里的次数是按照规模大小的变化分类的。

以此类推，对于规模为 `n` 的问题，一共要进行 `log(n)` 层的大小切分。在每一层里，我们都要进行合并，所涉及到的元素其实就是数组里的所有元素，因此，每一层的合并复杂度都是 `O(n)`，所以整体的复杂度就是 `O(nlogn)`。
