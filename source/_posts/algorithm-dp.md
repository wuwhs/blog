---
title: 「超详笔记」算法——动态规划（JS版）
date: 2020-11-23 22:30:30
tags: [algorithm, javascript]
---

### 判断动态规划

判断一个算法问题是否属于动态规划问题，主要依据有两点：

- 最优子结构：一个问题的最优解是由它的各个子问题的最优解决定的。
- 重叠子问题：解决一个问题需要拆解许多子问题，而这个子问题有重复。

### 最长子序列问题

`LeetCode` 第 `300` 题：给定一个无序的整数数组，找到其中最长子序列长度。

说明：可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。你算法的时间复杂度应该为 `O(n2)`。
注意：子序列和子数组不同，它并不要求元素是连续的。

示例

输入：`[ 10, 9, 2, 5, 3, 7, 101, 18 ]`
输出：`4`
即，最长的上升子序列是 `[2, 3, 7, 101]`，它的长度是 `4`。

#### 最长子序列问题解题思路

在给定的数组里，有很多的上升子序列，例如：[10, 101]，[9, 101]，[2, 5, 7, 101]，以及 [2, 3, 7, 101]，只需要找出其中一个最长的。

**思路 1**：暴力法

找出所有的子序列，然后从中返回一个最长的。

从一个数组中罗列出所有的非空子数组有： `n×(n + 1)/2` 种，即 `O(n2)`，那么罗列出所有的非空子序列有 `2n−1`  种。复杂度将是 `O(2n)`。

**思路 2**：缩小问题规模

1、找最优子结构：输入规模对半分。

![dp-1.gif](/gb/algorithm-dp/dp-1.gif)

`[10, 9, 2, 5]` 最长的子序列应该是 `[2, 5]`，而 `[3, 7, 101, 4]` 最长的子序列是 `[3, 7, 101]`，由于 `3` 比 `5` 小，无法简单地组合在一起。即该方法下，总问题的解无法直观地通过子问题的最优解求得。

2、找最优子结构：每次减一个。

假设 `f(n)` 表示的是数组 `nums[0，…，n−1]` 中最长的子序列，那么 `f(n−1)` 就是数组 `nums[0，…，n−2]` 中最长的子序列，依此类推，`f(1)` 就是 `nums[0]` 的最长子序列。

假设已经解决了 `f(1)，f(2)，… f(n−1)` 的问题，考虑最后一个数 `nums[n−1]`，也必然考虑到倒数第二个数 `nums[n−2]`，所以 `f(n)` 指：如果包含了最后的数，那么最长的子序列应该是什么。注意：最后这个数必须包含在子序列当中的。

![dp-2.gif](/gb/algorithm-dp/dp-2.gif)

如何通过 `f(1)，f(2)，…f(n−1)` 推导出 `f(n)` 呢？由于最后一个数是 `4`，我们只需要在前面的 `f(1)，f(2)，…f(n−1)` 当中，找出一个以小于 `4` 的数作为结尾的最长的子序列，然后把 `4` 添加到最后，那么 `f(n)` 就一定是以 `4` 作为结尾的最长的子序列了。

![dp-3.gif](/gb/algorithm-dp/dp-3.gif)

最长的子序列并不一定会包含 `4`，遍历 `f(1)，f(2)，…f(n−1)` ，找出最长的。例如，以 `101` 结尾的最长的上升子序列是什么。

![dp-4.gif](/gb/algorithm-dp/dp-4.gif)
