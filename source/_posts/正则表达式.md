---
title: 正则表达式
date: 2018-06-22 15:45:30
tags: javascript 正则
categories: javascript
---

对字符串的处理，一般分为字符串操作和正则操作。

##### 字符串操作

- str.search(regStr) 返回regStr在str中第一个出现的位置
- str.replace(regStr,newStr) 返回替换在str中regStr后字符串
- str.substring(n1,n2) 返回str从n1位置到n2位置前一个字符串
- str.chartAt(n) 返回n位置字符
- str.split(regStr) 返回以regStr隔开的数组
- str.match(reg) 返回在str中符合正则reg的字符串数组

##### 正则操作

var reg=new RegExp(regStr,'i'); //创建正则对象

var reg=/regStr/i; //隐式创建正则对象

- reg.test(str) str是否包含reg返回true/false
- reg.exec(str) 返回匹配到的字符串和最后一次的匹配字符串最后位置的下一个索引

#### 基础用法

1. /a|b/ a或b
2. /[abc]/ a或b或c
3. /[a-zA-Z0-9]/ 所有数字和字母
4. /[^a-zA-Z0-9]/ 除了数字和字母
5. /.+/ 任意字符
6. /\d/ 等价于/[0-9]/ 数字
7. /\w/ 等价于/[a-z0-9_]/ 数字、字母和下划线
8. /\s/ 等价于/" "/ 空格
9. /\D/ 等价于/[^0-9]/ 非数字
10. /\W/ 等价于/[^a-z0-9_]/ 除了数字、字母和划线
11. /\S/ 等价于/[^" "]/ 除了空格
12. /\d{n,m}/ 数字最少出现n次，最多出现m次
13. /\d{1,}/ 等价于/\d+/ 数字最少出现1次
14. /\d{0,}/ 等价于/\d*/ 数字最少出现0次
15. /\d{0,1}/ 等价于/\d?/ 数字最多出现1次
16. /^\d$/ 以数字开头且以数字结尾
17. /[\u4e00-\u9fa5]/ 汉字匹配范围
18. \b 单词边界
19. \B 非单词边界
20. ?=n 匹配任何其后紧接指定字符串n的字符串
21. ?!n 匹配任何其后没有紧接指定字符串n的字符串

#### 疑难点

在个人接触正则过程中遇到的一些不易理解的地方
> 用圆括号将所有选择项括起来，相邻的选择项之间用|分隔。但用圆括号会有一个副作用，是相关的匹配会被缓存，此时可用?:放在第一个选项前来消除这种副作用。其中?:是非捕获元之一，还有两个非捕获元是?=和?!，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。

表达式 | 描述
---|---
(?:pattern) | 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 "或" 字符 (\|) 来组合一个模式的各个部分是很有用。例如， 'industr(?:y\|ies) 就是一个比 'industry\|industries' 更简略的表达式。
(?=pattern | 正向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，'Windows (?=95\|98\|NT\|2000)' 能匹配 "Windows 2000" 中的 "Windows" ，但不能匹配 "Windows 3.1" 中的 "Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。
(?!pattern) | 负向预查，在任何不匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如'Windows (?!95\|98\|NT\|2000)' 能匹配 "Windows 3.1" 中的 "Windows"，但不能匹配 "Windows 2000" 中的 "Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。

一直对正则中的match和exec不易分清，下面来做一下比较。

##### 1. match

match方法属于String正则表达方法

语法:

```
str.match(regexp)
```


str：要进行匹配的字符串

regexp：一个正则表达式(或者由RegExp()构造成的正则表达式)

match的用法主要区分就是正则表达式是否有全局标示g

1. 如果有g全局标志，那么返回的数组保存的是，所有匹配的内容。

2. 如果没有g全局标志，那么返回的数组arr.arr[0]保存的是完整的匹配.arr[1]保存的是第一个括号里捕获的字串，依此类推arr[n]保存的是第n个括号捕获的内容。

##### 2. exec

与match方法不同exec属于正则表达式的方法

语法：
```
var result1 = regexp.exec(str);
```

regexp：正则表达式

str：要匹配的字串

exec与match的关联就是exec（g有没有都无影响）就等价于不含有g全局标志的match，即返回数组arr[0]为匹配的完整串，其余的为括号里捕获的字符串。

但如果有g对exec本身的影响是，当一个具有g的正则表达式调用exec()时，他将该对象的lastIndex设置到紧接这匹配子串的字符位置。当第二次调用exec时将从
lastIndex所指示的字符位置开始检索，利用这个特点可以反复调用exec遍历所有匹配，等价于match具有g标志。


```
var arrmatch = str.match(reg);
for(var i =0; i < arrmatch.length; i++){
    document.write(arrmatch[i] +"---->");
}
```
可见上面的exec和match是等价的.

reg.exec(str) 返回匹配到的字符串和最后一次的匹配字符串最后位置的下一个索引如：


```
var str = "abc123bef345olj89,ed";
var reg = /\d+/g;

console.log(reg.exec(str));
console.log(reg.lastIndex);

console.log(reg.exec(str));
console.log(reg.lastIndex);

console.log(reg.exec(str));
console.log(reg.lastIndex);

console.log(reg.exec(str));
console.log(reg.lastIndex);

```

结果

![image](http://note.youdao.com/yws/public/resource/b9cdada69234d36736d09235b516171c/xmlnote/519D4819520846F7BC55955A09812668/6105)

#### 总结

- 主要区分match具有g和没有g的区别，没有g的时候与exec是等价的。

- 而exec返回的串类型不受g影响，但具有g时候会驱动lastIndex可以模拟遍历所有匹配，可以与match具有g的时候等价。

#### 顺便加强理解

1. ip正则表达式
格式由"."分割成四段，每一段范围是0-255，拿出其中一段进行分析

范围 | 表达式
---|---
0-9 | \d
10-99 | [1-9]\d
100-199 | 1\d{2}
200-249 | 2[0-4]\d
250-255 | 25[0-5]

所以，其中一段构成的正则表达式是
```
\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5]
```
，
整个ip正则为

```
/^(\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5])$/
```
2. 同理端口号范围是0-65535

范围 | 表达式
---|---
0-9 | \d
10-99 | [1-9]\d
100-999 | [1-9]\d{2}
1000-9999 | [1-9]\d{3}
10000-59999 | [1-5]\d{4}
60000-64999 | 6[0-4]\d{3}
65000-65499 | 65[0-4]\d{2}
65500-65529 | 655[0-2]\d
65530-65535 | 65553[0-5]

所以，整个端口号正则为

```
/\d|[1-9]\d{1,3}|[1-5]d{4}|6[0-4]\d{3}|65[0-4]\d{2}|655[0-2]\d|65553[0-5]/
```
